# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Аксенов А.Е.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |                   |
| Левинская М.А.|              |                   |

## Введение
Выполняя курсовой проект, я:
* Получу полезные знания о том, как работает парсинг, а также способы его осуществления;
* Освоб навыки работы с файлами типа GEDCOM 
* Получу новые навыки при работе с Prolog и другими языками

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. [На оценки хорошо и отлично] Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я создал своё родословное дерево на сайте MyHeritage.com. Всего в дереве 23 человека - достаточно для проведения данной работы. Само дерево было экспортировано в файл .ged

## Конвертация родословного дерева

Выбор пал на язык Python 3, поскольку я работал с ним ранее и, следовательно, написать парсер на нём будет нетрудно.
Сама программа работает доволно просто: мы построчно просматриваем файл FamilyTree.ged и находим данные человека - Имя, Фамилия, а также данные о Муже\Жене, Детях (Если они есть):

```python3
for input_string in input_file:
    if input_string == "\n":
        continue
    elif input_string.find("GIVN", 0, len(input_string)) > -1:
        name = input_string[7:len(input_string) - 1]

    elif input_string.find("SURN", 0, len(input_string)) > -1:
        surname = input_string[7:len(input_string) - 1]
        table[n] = name + ' ' + surname
        n = n + 1
        
    elif input_string.find("HUSB", 0, len(input_string)) > -1:
        i = input_string.index("I", 0, len(input_string))
        husb_id = input_string[i+2:len(input_string) - 2]

    elif input_string.find("WIFE", 0, len(input_string)) > -1:
        i = input_string.index("@", 0, len(input_string))
        wife_id = input_string[i+3:len(input_string) - 2] 

    elif input_string.find("CHIL", 0, len(input_string)) > -1:
        i = input_string.index("@", 0, len(input_string))
        child_id = input_string[i+3:len(input_string) - 2] 
        output_file.write("father('{0}', '{1}').\n".format(table[int(husb_id)], table[int(child_id)]))
        output_file.write("mother('{0}', '{1}').\n".format(table[int(wife_id)], table[int(child_id)]))
```
Как показывает кусок программы сверху, полученные данные записываются в предикаты father(отец, потомок), mother(мать, потомок) и сохраняются в файл result.pl

```prolog
father('Евгений Аксёнов', 'Александр Аксёнов').
mother('Анастасия Скворцова', 'Александр Аксёнов').
father('Евгений Аксёнов', 'Елена Аксёнова').
mother('Анастасия Скворцова', 'Елена Аксёнова').
father('Александр Скворцов', 'Анастасия Скворцова').
mother('Валентина Брагина', 'Анастасия Скворцова').
father('Анатолий Аксёнов', 'Евгений Аксёнов').
mother('Татьяна Майорова', 'Евгений Аксёнов').
father('Николай Аксёнов', 'Анатолий Аксёнов').
mother('Татьяна Быкова', 'Анатолий Аксёнов').
father('Николай Аксёнов', 'Людмила Аксёнова').
mother('Татьяна Быкова', 'Людмила Аксёнова').
father('Сергей Майоров', 'Татьяна Майорова').
mother('Екатерина Сазонова', 'Татьяна Майорова').
father('Сергей Майоров', 'Инна Майорова').
mother('Екатерина Сазонова', 'Инна Майорова').
father('Василий Скворцов', 'Александр Скворцов').
mother('Екатерина Добрякова', 'Александр Скворцов').
father('Василий Скворцов', 'Виктор Скворцов').
mother('Екатерина Добрякова', 'Виктор Скворцов').
father('Василий Скворцов', 'Надежда Скворцова').
mother('Екатерина Добрякова', 'Надежда Скворцова').
father('Пётр Брагин', 'Валентина Брагина').
mother('Нина Исавнина', 'Валентина Брагина').
father('Пётр Брагин', 'Галина Брагина').
mother('Нина Исавнина', 'Галина Брагина').
father('Геннадий Муханин', 'Александр Муханин').
mother('Людмила Аксёнова', 'Александр Муханин').
```

## Предикат поиска родственника

По заданию мне нужно написать предикат, который ищет шурина (брата жены). Также в древе присутствует золовка (сестра мужа), поэтому написал и для неё (для нахождения обоих код абсолютно одинаков, разница лишь в переменных).
Сам код работает следующим образом: 
1. Предикат, проверяющий, являются ли два человека братом или сетрой:
```prolog
are_siblings(X, Y):-
    father(Z, X),
    mother(H, X),
    father(Z, Y),
    mother(H, Y),
    X \= Y.
```
2. Предикат, проверяющий, женаты ли два человека:
```prolog
are_married(H, W):-
    father(H, C),
    mother(W, C).
```
3. Предикат, определяюший шурина:
```prolog
brother_in_law(B, X):-
    are_married(X, W),
    mother(W,L),
    are_siblings(B, W),
    father(B, F).
```
4. Предикат, определяюший золовку:
```prolog
sister_in_law(B, X):-
    are_married(X, B),
    father(B,L),
    are_siblings(B, W),
    mother(W, F).
```
Результаты работы предиката:
```prolog
?- brother_in_law(X,Y).
X = 'Анатолий Аксёнов',
Y = 'Геннадий Муханин'

?- sister_in_law(X,Y).
X = 'Людмила Аксёнова',
Y = 'Геннадий Муханин'
```

## Выводы
В ходе выполнения данной курсовой работы мне удалось закрепить навыки работы с Prolog. Также пришлось подумать о том, какие задачи решаются эффективно с помощью Prologа.

В итоге я хочу сказать, что данный курс дался мне нелегко, так как тяжело было перестроиться на новую парадигму программирования, но впечатления и опыт, которые он оставил, подарили мне желание изучать все больше разных граней такого занятия, как программирование.
